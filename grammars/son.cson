name: "SON"
scopeName: "source.son"
fileTypes: ["son", "sy"]
patterns: [include: "#blockInnards"]

repository:
	main:
		patterns: [
			{include: "#comment"}
			{include: "#regexp"}
			{include: "#fieldQuotedEarly"}
			{include: "#string"}
			{include: "#stringJunk"}
			{include: "#block"}
			{include: "#field"}
			{include: "#array"}
			{include: "#bytestream"}
			{include: "#brackets"}
			{include: "#boolean"}
			{include: "#null"}
			{include: "#date"}
			{include: "#number"}
			{include: "#comma"}
			{include: "#operator"}
		]
	
	# [Array]
	name: "meta.array.son"
	array:
		begin: "\\["
		end:   "\\]"
		beginCaptures: 0: name: "punctuation.definition.array.begin.bracket.square.son"
		endCaptures:   0: name: "punctuation.definition.array.end.bracket.square.son"
		patterns: [
			{include: "#main"}
			{include: "#unquoted"}
		]
	
	# { Block }
	block:
		patterns: [{
			# Tagged block {
			name: "meta.block.tagged.son"
			begin: "((?:[^{}\\[\\]:\\s,]|[:#](?=\\S))(?:[^:{}]|:(?=\\S)|\\\\[{:])*?)({)"
			end:   "}"
			beginCaptures:
				1: name: "entity.name.block.tag.label.son"
				2: name: "punctuation.section.scope.block.begin.bracket.curly.son"
			endCaptures:
				0: name: "punctuation.section.scope.block.end.bracket.curly.son"
			patterns: [include: "#blockInnards"]
		},{
			name:  "meta.block.son"
			begin: "{"
			end:   "}"
			beginCaptures: 0: name: "punctuation.section.scope.block.begin.bracket.curly.son"
			endCaptures:   0: name: "punctuation.section.scope.block.end.bracket.curly.son"
			patterns: [include: "#blockInnards"]
		}]
	
	# Stuff matched directly inside of a block
	blockInnards:
		patterns: [
			{include: "#fieldQuotedEarly"}
			{include: "#main"}
			
			# Assumed to be a multiline field name
			match: "((?:[^{}\\[\\]:\\s,]|[:#](?=\\S))(?:[^:{}]|:(?=\\S)|\\\\[{:])*?)"
			captures:
				1: name: "entity.name.tag.property.son"
		]
	
	# Brackets (expressions)
	brackets:
		name:  "meta.expression.son"
		begin: "\\("
		end:   "\\)"
		beginCaptures: 0: name: "punctuation.section.scope.block.begin.bracket.round.son"
		endCaptures:   0: name: "punctuation.section.scope.block.end.bracket.round.son"
		patterns: [include: "#main"]
	
	# Boolean keywords
	boolean:
		patterns: [{
			# True
			name: "constant.language.boolean.true.son"
			match: """(?x)
				(?:^|(?<=[\\s\\[{,]))
				(?:true|yes|on|TRUE|YES|ON)
				(?=$|[\\s\\]},])
			"""
		},{
			# False
			name: "constant.language.boolean.false.son"
			match: """(?x)
				(?:^|(?<=[\\s\\[{,]))
				(?:false|no|off|TRUE|YES|ON)
				(?=$|[\\s\\]},])
			"""
		}]
	
	# Bytestream: <37 A2 E7 7E>
	bytestream:
		name:  "meta.bytestream.son"
		begin: "<"
		end:   ">"
		beginCaptures: 0: name: "punctuation.section.bytestream.begin.bracket.angle.son"
		endCaptures:   0: name: "punctuation.section.bytestream.end.bracket.angle.son"
		patterns: [{
			# Byte
			name:  "constant.numeric.integer.int.hexadecimal.hex.son"
			match: "[A-Fa-f0-9]+"
		},{
			# Embedded comments
			include: "#comment"
		},{
			# Unexpected junk
			name: "invalid.illegal.character.son"
			match: "[^\\s>]+"
		}]
	
	# Comma
	comma:
		name: "punctuation.separator.delimiter.comma.son"
		match: ","
	
	# Comments
	comment:
		patterns: [{
			### Block comment ###
			name:  "comment.block.son"
			begin: "(?:^|(?<=\\s|\\xC2\\xAD|\\xAD))(\#{3,})(?=\\s|$)"
			end:   "\\1"
			beginCaptures: 1: name: "punctuation.definition.comment.begin.son"
			endCaptures:   0: name: "punctuation.definition.comment.end.son"
		},{
			# Single-line comment
			name:  "comment.line.number-sign.son"
			begin: "(?:^|(?<=\\s|\\xC2\\xAD|\\xAD))#(?=\\s|$)"
			end:   "$"
			beginCaptures:
				0: name: "punctuation.definition.comment.son"
		}]

	# Date or datetime
	date:
		name: "constant.other.date.son"
		match: """(?x)
			# Date
			[0-9]{4} - # Year
			[0-9]{2} - # Month
			[0-9]{2}   # Day
			
			# Time
			(?:
				(?:T|\\s+)
				[0-9]{1,2} :     # Hours
				[0-9]{1,2} :     # Minutes
				[0-9]{1,2}       # Seconds
				(?:\\.[0-9]+)?   # Milliseconds
				(\\+[0-9]{4}|Z)? # Timezone
			)?
			
			# Followed by delimiter, EOL, or comment
			(?= \\s* (?:$|[,\\]}])
			|   \\s+ \\#(?:$|\\s)
			)
		"""

	# Escaped character
	escape:
		patterns: [{
			# Newline hack
			name:  "constant.character.escape.newline.son"
			begin: "\\\\$\\s*"
			end:   "^"
			beginCaptures:
				0: name: "punctuation.backslash.definition.escape.son"
		},{
			# Hexadecimal escape: \x1B
			name: "constant.character.escape.unicode.son"
			match: "(\\\\)x[A-Fa-f0-9]{2}"
			captures:
				1: name: "punctuation.backslash.definition.escape.son"
		},{
			# Unicode escape: \u0032
			name:  "constant.character.escape.unicode.son"
			match: "(\\\\)u[A-Fa-f0-9]{4}"
			captures:
				1: name: "punctuation.backslash.definition.escape.son"
		},{
			# Unicode escape: \u{1B240}
			name: "constant.character.escape.unicode.son"
			match: "(\\\\)u({)[A-Fa-f0-9]+(})"
			captures:
				1: name: "punctuation.backslash.definition.escape.son"
				2: name: "punctuation.definition.unicode-escape.begin.bracket.curly.son"
				3: name: "punctuation.definition.unicode-escape.end.bracket.curly.son"
		},{
			# Invalid unicode escape: \u{nope}, \u{}
			name: "invalid.illegal.unicode-escape.son"
			match: "\\\\u{[^}\"]*}"
		},{
			# Invalid unicode escape: \uNOPE
			name: "invalid.illegal.unicode-escape.son"
			match: "\\\\u(?![A-Fa-f0-9]{4})[^\"]*"
		},{
			# Anything else
			name: "constant.character.escape.son"
			match: "(\\\\)."
			captures:
				0: name: "punctuation.backslash.definition.escape.son"
		}]

	# Only one escape possible in a verbatim string: \`
	escapeVerbatim:
		name: "constant.character.escape.backtick.son"
		match: "(\\\\)`"
		captures:
			1: name: "punctuation.backslash.definition.escape.son"

	# Named property
	field:
		name: "meta.field.son"
		begin: """(?x)
			(?:
				# Quoted property name
				(?<=[:{\\[]) \\s*
				(?: ("(?:[^"\\\\]|\\\\.)*")
				|   ('(?:[^'\\\\]|\\\\.)*')
				|   (`(?:[^`\\\\]|\\\\.)*`)
				) \\s* (:)
				
				|
				
				# Unquoted property name
				([^{}\\[\\]<>\\s].*?)
				(?<!\\\\) (:)
				
				|
				
				# Presumably one following a multiline string
				(?<=["'`]) \\s* (:)
			)
			(?=\\s|$)
			\\s*
		"""
		end: "(?=\\s*})|^(?!\\G)"
		beginCaptures:
			1: name: "entity.name.tag.property.quoted.double.son",   patterns: [include: "#escape"]
			2: name: "entity.name.tag.property.quoted.single.son",   patterns: [include: "#escape"]
			3: name: "entity.name.tag.property.quoted.backtick.son", patterns: [include: "#escapeVerbatim"]
			4: name: "punctuation.separator.key-value.son"
			5: name: "entity.name.tag.property.son",                 patterns: [include: "#escape"]
			6: name: "punctuation.separator.key-value.son"
			7: name: "punctuation.separator.key-value.son"
		patterns: [include: "#fieldInnards"]

	# Quoted field, hack for preceding #string rule
	fieldQuotedEarly:
		name: "meta.field.son"
		begin: """(?x) ^ \\s*
			(?: ("(?:[^"\\\\]|\\\\.)*")
			|   ('(?:[^'\\\\]|\\\\.)*')
			|   (`(?:[^`\\\\]|\\\\.)*`)
			) \\s* (:)
			(?=\\s|$)
			\\s*
		"""
		end: "(?=\\s*})|^(?!\\G)"
		beginCaptures:
			1: name: "entity.name.tag.property.quoted.double.son",   patterns: [include: "#escape"]
			2: name: "entity.name.tag.property.quoted.single.son",   patterns: [include: "#escape"]
			3: name: "entity.name.tag.property.quoted.backtick.son", patterns: [include: "#escapeVerbatim"]
			4: name: "punctuation.separator.key-value.son"
		patterns: [include: "#fieldInnards"]
	
	fieldInnards:
		patterns: [
			{include: "#main"}
			{include: "#unquoted"}
		]

	# Null keyword
	null:
		name: "constant.language.null.son"
		match: """(?x)
			(?:^|(?<=[\\s\\[{,]))
			(?:null|NULL)
			(?=$|[\\s\\]},])
		"""

	# Numeric literals
	number:
		match: """(?x)
			(?:^|(?<=[\\s\\[\\({,~]))
			(?: ([-+]?0[xX][A-Fa-f0-9]+) # Hexadecimal
			|   ([-+]?0[oO][0-7]+)       # Octal
			|   ([-+]?0[bB][0-1]+)       # Binary
			|   ([-+]?[0-9]+\\.(?:[0-9]*[eE][+-]?[0-9]+|[0-9]+)) # Float
			|   ([-+]?[0-9]+(?:[eE][+-]?[0-9]+)?) # Integer
			)
			\\s*
			(?= $
			|   [-+*/%^&|\\)<>\\s\\]},]
			|   (?<=\\s)\\#(?=\\s|$)
			)
		"""
		captures:
			1: name: "constant.numeric.integer.int.hexadecimal.hex.son"
			2: name: "constant.numeric.integer.int.octal.oct.son"
			3: name: "constant.numeric.integer.int.binary.bin.son"
			4: name: "constant.numeric.float.decimal.dec.son"
			5: name: "constant.numeric.integer.int.decimal.dec.son"

	# Expression operators
	operator:
		patterns: [{
			# Arithmetic
			name: "keyword.operator.arithmetic.son"
			match: "\\*\\*|[-+*/%]"
		},{
			# Bitwise
			name: "keyword.operator.bitwise.son"
			match: "(<<|>>|>>>|[~&|^])"
		}]

	# Regular expressions
	regexp:
		patterns: [{
			# Multiline regexp
			name:  "string.regexp.multiline.son"
			begin: "///"
			end:   "(///)([A-Za-z]*)"
			beginCaptures:
				0: name: "punctuation.definition.string.begin.son"
			endCaptures:
				1: name: "punctuation.definition.string.end.son"
				2: patterns: [include: "source.regexp#scopedModifiers"]
			patterns: [include: "source.regexp#main"]
		},{
			# Single-line regexp
			name: "string.regexp.son"
			match: "(/)(.*)(/)([A-Za-z]*)"
			captures:
				1: name: "punctuation.definition.string.begin.son"
				3: name: "punctuation.definition.string.end.son"
				2: patterns: [include: "source.regexp#main"]
				4: patterns: [include: "source.regexp#scopedModifiers"]
		}]

	# Quoted string literals
	string:
		patterns: [{
			# """ Double-quoted heredoc """
			name: "string.quoted.double.heredoc.son"
			begin: '"""'
			end:   '"""'
			beginCaptures: 0: name: "punctuation.definition.string.begin.son"
			endCaptures:   0: name: "punctuation.definition.string.end.son"
			patterns: [include: "#stringInnards"]
		},{
			# ''' Single-quoted heredoc '''
			name: "string.quoted.single.heredoc.son"
			begin: "'''"
			end:   "'''"
			beginCaptures: 0: name: "punctuation.definition.string.begin.son"
			endCaptures:   0: name: "punctuation.definition.string.end.son"
			patterns: [include: "#stringInnards"]
		},{
			# ``` Verbatim heredoc ```
			name: "string.quoted.verbatim.backtick.heredoc.son"
			begin: "```"
			end:   "```"
			beginCaptures: 0: name: "punctuation.definition.string.begin.son"
			endCaptures:   0: name: "punctuation.definition.string.end.son"
			patterns: [{
				# Only one escape possible: \```
				name: "constant.character.escape.heredoc.son"
				match: "(\\\\)```"
				captures:
					1: name: "punctuation.backslash.definition.escape.son"
			}]
		},{
			# "Double-quoted string"
			name:  "string.quoted.double.son"
			begin: '"'
			end:   '"'
			beginCaptures: 0: name: "punctuation.definition.string.begin.son"
			endCaptures:   0: name: "punctuation.definition.string.end.son"
			patterns: [include: "#stringInnards"]
		},{
			# 'Single-quoted string'
			name: "string.quoted.single.son"
			begin: "'"
			end:   "'"
			beginCaptures: 0: name: "punctuation.definition.string.begin.son"
			endCaptures:   0: name: "punctuation.definition.string.end.son"
			patterns: [include: "#stringInnards"]
		},{
			# `Verbatim string`
			name: "string.quoted.verbatim.backtick.son"
			begin: "`"
			end:   "`"
			beginCaptures: 0: name: "punctuation.definition.string.begin.son"
			endCaptures:   0: name: "punctuation.definition.string.end.son"
			patterns: [include: "#escapeVerbatim"]
		}]

	# Unexpected crap found after a closed quote
	stringJunk:
		name: "invalid.illegal.syntax.son"
		begin: "(?<=[\"'`])(?!\\s*$)(?=\\s*[^:,}\\]])"
		end: "(?=[:,}\\]])"

	stringInnards:
		patterns: [
			{include: "#url"}
			{include: "#escape"}
		]

	# Unquoted string
	unquoted:
		name: "string.unquoted.son"
		match: """(?x)
			(?:^|\\G|(?<=,))
			\\s*
			
			(?! ~? [-+]? [0-9])
			[^\\s{}\\[\\]<:"'`]
			
			(?: [^\\#,}\\]:]
			|   (?<=\\S) [\\#:]
			|   [:\\#] (?=\\S)
			)*
			(?!
				\\s*
				(?:[\\{:])
			)
		"""
		captures:
			0: patterns: [include: "#url"]

	# Underlinked URLs. Not a datatype.
	url:
		patterns: [{
			# https://etc, git://github.com/
			name: "constant.other.reference.link.underline.son"
			match: """(?x) \\b
				# Protocol
				( https?
				| s?ftp
				| ftps
				| file
				| wss?
				| smb
				| git (?:\\+https?)
				| ssh
				| rsync
				| afp
				| nfs
				| (?:x-)?man(?:-page)?
				| gopher
				| txmt
				| issue
				| atom
				) ://
				
				# Path specifier
				(?:
					(?! \\#\\w*\\#)
					(?: [-:\\@\\w.,~%+_/?=&\\#;|!])
				)+
				
				# Don't include trailing punctuation
				(?<![-.,?:\\#;])
			"""
		},{
			# mailto:this@guy
			name: "markup.underline.link.mailto.son"
			match: """(?x) \\b
				mailto: (?:
					(?! \\#\\w*\\#)
					(?: [-:@\\w.,~%+_/?=&\\#;|!])
				)+
				(?<![-.,?:\\#;])
			"""
		}]
