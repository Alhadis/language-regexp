\n
\k<n>     \k'n'
\k<-n>    \k'-n'
\k<name>  \k'name'


\k<n+level> \k'n+level'
\k<n-level> \k'n-level'



\A(?<a>|.|(?:(?<b>.)\o{22}qr\g<a>\k<b>))\z
\A(?<a>|.|(?:(?<b>.)\o{22}qr\g<a>\k<b+0>))\z


\h, \H
(?<name>...), (?'name'...)
\k<name>
\g<name>, \g<group-num>

\p{k}
\pP
\g{1}
\12

\o{2,2}
\o{22424}

\p{ASCII_Hex_Digit=True}
\p{ASCII_Hex_Digit=False}

(?-imx:subexp)

(?<element> \g<stag> \g<content>* \g<etag> ){0}
(?<stag> < \g<name> \s* > ){0}
(?<name> [a-zA-Z_:]+ ){0}
(?<content> [^<&]+ (\g<element> | [^<&]+)* ){0}
(?<etag> </ \k<name+1> >){0}
\g<element>


(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})

\p{X_POSIX_Digit}

\0
\333
\n
\a
\A
\b
\b
\B
\cX
\C-[
\d
\D
\e
\E
\f
\F
\g{GROUP}
\g1
\G
\h
\H
\k<GROUP>
\k'NAME'
\K
\l
\L
\n
\N{NAME}
\o{0333}
\p{PROP}
\P{PROP}
\Q
\r
\R
\s
\S
\t
\u
\U
\v
\V
\w
\W
\x{FFFF}
\X
\z
\Z


\t            tab                   (HT, TAB)
\n            newline               (LF, NL)
\r            return                (CR)
\f            form feed             (FF)
\a            alarm (bell)          (BEL)
\e            escape (think troff)  (ESC)
\cK           control char          (example: VT)
\x{00}, \x00  character whose ordinal is the given hexadecimal number
\N{name}      named Unicode character or character sequence
\N{U+263D}    Unicode character     (example: FIRST QUARTER MOON)
\o{00}, \000  character whose ordinal is the given octal number
\l            lowercase next char (think vi)
\u            uppercase next char (think vi)
\L            lowercase until \E (think vi)
\U            uppercase until \E (think vi)
\Q            quote (disable) pattern metacharacters until \E
\E            end either case modification or quoted section, think vi

[\N{APOSTROPHE}-\N{QUESTION MARK}]

[01[:alpha:]%]
See also "\b{gcb}".



	[[:alpha:]]
	[[:alnum:]]
	[[:ascii:]]
	[[:blank:]]
	[[:cntrl:]]
	[[:digit:]]
	[[:graph:]]
	[[:lower:]]
	[[:print:]]
	[[:punct:]]
	[[:space:]]
	[[:upper:]]
	[[:^word:]]
	[[:xdigit:]]
	
	[[:...:]]      ASCII-range          Full-range       Backslash
	--------------------------------------------------------------
	alpha         \p{PosixAlpha}       \p{XPosixAlpha}
	alnum         \p{PosixAlnum}       \p{XPosixAlnum}
	ascii         \p{ASCII}
	blank         \p{PosixBlank}       \p{XPosixBlank}     \h
	                                   \p{HorizSpace}
	cntrl         \p{PosixCntrl}       \p{XPosixCntrl}
	digit         \p{PosixDigit}       \p{XPosixDigit}     \d
	graph         \p{PosixGraph}       \p{XPosixGraph}
	lower         \p{PosixLower}       \p{XPosixLower}
	print         \p{PosixPrint}       \p{XPosixPrint}
	punct         \p{PosixPunct}       \p{XPosixPunct}
	              \p{PerlSpace}        \p{XPerlSpace}      \s
	space         \p{PosixSpace}       \p{XPosixSpace}
	upper         \p{PosixUpper}       \p{XPosixUpper}
	word          \p{PosixWord}        \p{XPosixWord}      \w
	xdigit        \p{PosixXDigit}      \p{XPosixXDigit}




(?P<NAME>pattern) = (?<NAME>pattern)
(?P=NAME)         = \g{NAME}
(?P>NAME)         = (?&NAME)


?           0 or 1, greedy
?+          0 or 1, possessive
??          0 or 1, lazy
*           0 or more, greedy
*+          0 or more, possessive
*?          0 or more, lazy
+           1 or more, greedy
++          1 or more, possessive
+?          1 or more, lazy
{1}         exactly n
{1,3}       at least n, no more than m, greedy
{1,3}+      at least n, no more than m, possessive
{1,3}?      at least n, no more than m, lazy
{1,}        n or more, greedy
{1,}+       n or more, possessive
{1,}?       n or more, lazy



(...)           capturing group
(?<name>...)    named capturing group (Perl)
(?'name'...)    named capturing group (Perl)
(?P<name>...)   named capturing group (Python)
(?:...)         non-capturing group
(?|...)         non-capturing group; reset group numbers for capturing groups in each alternative


(?i)            caseless
(?J)            allow duplicate names
(?m)            multiline
(?s)            single line (dotall)
(?U)            default ungreedy (lazy)
(?x)            extended (ignore white space)
(?-s)           unset option(s)


(*ACCEPT)
(*COMMIT)
(*FAIL)
(*F)
(*MARK:NAME)
(*:NAME)
(*PRUNE)
(*PRUNE:NAME)
(*SKIP)
(*SKIP:NAME)
(*THEN)
(*THEN:NAME)



(*LIMIT_MATCH=d)
(*LIMIT_RECURSION=d)
(*NO_AUTO_POSSESS)
(*NO_START_OPT)
(*UTF8)
(*UTF16)
(*UTF32)
(*UTF)
(*UCP)
(*CR)           carriage return only
(*LF)           linefeed only
(*CRLF)         carriage return followed by linefeed
(*ANYCRLF)      all three of the above
(*ANY)          any Unicode newl
(*BSR_ANYCRLF)  CR, LF, or CRLF
(*BSR_UNICODE)  any Unicode newline sequence


\n              reference by number (can be ambiguous)
\gn             reference by number
\g{n}           reference by number
\g{-n}          relative reference by number
\k<name>        reference by name (Perl)
\k'name'        reference by name (Perl)
\g{name}        reference by name (Perl)
\k{name}        reference by name (.NET)
(?P=name)       reference by name (Python)



SUBROUTINE REFERENCES (POSSIBLY RECURSIVE)

	(?R)            recurse whole pattern
	(?n)            call subpattern by absolute number
	(?+2)           call subpattern by relative number
	(?-2)           call subpattern by relative number
	(?&name)        call subpattern by name (Perl)
	(?P>name)       call subpattern by name (Python)
	\g<name>        call subpattern by name (Oniguruma)
	\g'name'        call subpattern by name (Oniguruma)
	\g<2>           call subpattern by absolute number (Oniguruma)
	\g'2'           call subpattern by absolute number (Oniguruma)
	\g<+2>          call subpattern by relative number (PCRE extension)
	\g'+2'          call subpattern by relative number (PCRE extension)
	\g<-2>          call subpattern by relative number (PCRE extension)
	\g'-2'          call subpattern by relative number (PCRE extension)

CONDITIONAL PATTERNS

	(?(condition)yes-pattern)
	(?(condition)yes-pattern|no-pattern)

	(?(2)yes|no)        absolute reference condition
	(?(+2)yes|no)       relative reference condition
	(?(-2)yes|no)       relative reference condition
	(?(<name>)yes|no)   named reference condition (Perl)
	(?('name')yes|no)   named reference condition (Perl)
	(?(name)yes|no)     named reference condition (PCRE)
	(?(R)yes|no)        overall recursion condition
	(?(R2)yes|no)       specific group recursion condition
	(?(R&name)yes|no)   specific recursion condition
	(?(DEFINE)yes|no)   define subpattern for reference
	(?(assert)yes|no)   assertion condition
	(?(?<=AA)yes|no)    lookbehind condition
	(?(?=AA)yes|no)     lookahead condition
	

	(*ACCEPT)       force successful match
	(*FAIL)         force backtrack; synonym (*F)
	(*MARK:NAME)    set name to be passed back; synonym (*:NAME)


BACKTRACKING CONTROL

	The following act immediately they are reached:

	(*ACCEPT)       force successful match
	(*FAIL)         force backtrack; synonym (*F)
	(*MARK:NAME)    set name to be passed back; synonym (*:NAME)

	The following act only when a subsequent match failure causes a backtrack to reach them. They all force a match failure, but they differ in what happens afterwards.  Those  that  advance  the  start-of-match
	point do so only if the pattern is not anchored.

	(*COMMIT)       overall failure, no advance of starting point
	(*PRUNE)        advance to next starting character
	(*PRUNE:NAME)   equivalent to (*MARK:NAME)(*PRUNE)
	(*SKIP)         advance to current matching position
	(*SKIP:NAME)    advance to position corresponding to an earlier
	                (*MARK:NAME); if not found, the (*SKIP) is ignored
	(*THEN)         local failure, backtrack to next alternation
	(*THEN:NAME)    equivalent to (*MARK:NAME)(*THEN)

CALLOUTS
	(?C)      callout
	(?C1)     callout with data n
